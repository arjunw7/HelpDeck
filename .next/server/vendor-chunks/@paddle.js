/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paddle";
exports.ids = ["vendor-chunks/@paddle"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paddle/paddle-js/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@paddle/paddle-js/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  function asyncGeneratorStep(n, t, e, r, o, a, c) {\n    try {\n      var i = n[a](c),\n        u = i.value;\n    } catch (n) {\n      return void e(n);\n    }\n    i.done ? t(u) : Promise.resolve(u).then(r, o);\n  }\n  function _asyncToGenerator(n) {\n    return function () {\n      var t = this,\n        e = arguments;\n      return new Promise(function (r, o) {\n        var a = n.apply(t, e);\n        function _next(n) {\n          asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n        }\n        function _throw(n) {\n          asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n        }\n        _next(void 0);\n      });\n    };\n  }\n  function _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n      value: t,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[r] = t, e;\n  }\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _objectWithoutProperties(e, t) {\n    if (null == e) return {};\n    var o,\n      r,\n      i = _objectWithoutPropertiesLoose(e, t);\n    if (Object.getOwnPropertySymbols) {\n      var s = Object.getOwnPropertySymbols(e);\n      for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n    }\n    return i;\n  }\n  function _objectWithoutPropertiesLoose(r, e) {\n    if (null == r) return {};\n    var t = {};\n    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n      if (e.includes(n)) continue;\n      t[n] = r[n];\n    }\n    return t;\n  }\n  function _regeneratorRuntime() {\n    _regeneratorRuntime = function () {\n      return e;\n    };\n    var t,\n      e = {},\n      r = Object.prototype,\n      n = r.hasOwnProperty,\n      o = Object.defineProperty || function (t, e, r) {\n        t[e] = r.value;\n      },\n      i = \"function\" == typeof Symbol ? Symbol : {},\n      a = i.iterator || \"@@iterator\",\n      c = i.asyncIterator || \"@@asyncIterator\",\n      u = i.toStringTag || \"@@toStringTag\";\n    function define(t, e, r) {\n      return Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }), t[e];\n    }\n    try {\n      define({}, \"\");\n    } catch (t) {\n      define = function (t, e, r) {\n        return t[e] = r;\n      };\n    }\n    function wrap(t, e, r, n) {\n      var i = e && e.prototype instanceof Generator ? e : Generator,\n        a = Object.create(i.prototype),\n        c = new Context(n || []);\n      return o(a, \"_invoke\", {\n        value: makeInvokeMethod(t, r, c)\n      }), a;\n    }\n    function tryCatch(t, e, r) {\n      try {\n        return {\n          type: \"normal\",\n          arg: t.call(e, r)\n        };\n      } catch (t) {\n        return {\n          type: \"throw\",\n          arg: t\n        };\n      }\n    }\n    e.wrap = wrap;\n    var h = \"suspendedStart\",\n      l = \"suspendedYield\",\n      f = \"executing\",\n      s = \"completed\",\n      y = {};\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    var p = {};\n    define(p, a, function () {\n      return this;\n    });\n    var d = Object.getPrototypeOf,\n      v = d && d(d(values([])));\n    v && v !== r && n.call(v, a) && (p = v);\n    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n    function defineIteratorMethods(t) {\n      [\"next\", \"throw\", \"return\"].forEach(function (e) {\n        define(t, e, function (t) {\n          return this._invoke(e, t);\n        });\n      });\n    }\n    function AsyncIterator(t, e) {\n      function invoke(r, o, i, a) {\n        var c = tryCatch(t[r], t, o);\n        if (\"throw\" !== c.type) {\n          var u = c.arg,\n            h = u.value;\n          return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n            invoke(\"next\", t, i, a);\n          }, function (t) {\n            invoke(\"throw\", t, i, a);\n          }) : e.resolve(h).then(function (t) {\n            u.value = t, i(u);\n          }, function (t) {\n            return invoke(\"throw\", t, i, a);\n          });\n        }\n        a(c.arg);\n      }\n      var r;\n      o(this, \"_invoke\", {\n        value: function (t, n) {\n          function callInvokeWithMethodAndArg() {\n            return new e(function (e, r) {\n              invoke(t, n, e, r);\n            });\n          }\n          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        }\n      });\n    }\n    function makeInvokeMethod(e, r, n) {\n      var o = h;\n      return function (i, a) {\n        if (o === f) throw Error(\"Generator is already running\");\n        if (o === s) {\n          if (\"throw\" === i) throw a;\n          return {\n            value: t,\n            done: !0\n          };\n        }\n        for (n.method = i, n.arg = a;;) {\n          var c = n.delegate;\n          if (c) {\n            var u = maybeInvokeDelegate(c, n);\n            if (u) {\n              if (u === y) continue;\n              return u;\n            }\n          }\n          if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n            if (o === h) throw o = s, n.arg;\n            n.dispatchException(n.arg);\n          } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n          o = f;\n          var p = tryCatch(e, r, n);\n          if (\"normal\" === p.type) {\n            if (o = n.done ? s : l, p.arg === y) continue;\n            return {\n              value: p.arg,\n              done: n.done\n            };\n          }\n          \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n        }\n      };\n    }\n    function maybeInvokeDelegate(e, r) {\n      var n = r.method,\n        o = e.iterator[n];\n      if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n      var i = tryCatch(o, e.iterator, r.arg);\n      if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n      var a = i.arg;\n      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n    }\n    function pushTryEntry(t) {\n      var e = {\n        tryLoc: t[0]\n      };\n      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n    }\n    function resetTryEntry(t) {\n      var e = t.completion || {};\n      e.type = \"normal\", delete e.arg, t.completion = e;\n    }\n    function Context(t) {\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }], t.forEach(pushTryEntry, this), this.reset(!0);\n    }\n    function values(e) {\n      if (e || \"\" === e) {\n        var r = e[a];\n        if (r) return r.call(e);\n        if (\"function\" == typeof e.next) return e;\n        if (!isNaN(e.length)) {\n          var o = -1,\n            i = function next() {\n              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n              return next.value = t, next.done = !0, next;\n            };\n          return i.next = i;\n        }\n      }\n      throw new TypeError(typeof e + \" is not iterable\");\n    }\n    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n      value: GeneratorFunctionPrototype,\n      configurable: !0\n    }), o(GeneratorFunctionPrototype, \"constructor\", {\n      value: GeneratorFunction,\n      configurable: !0\n    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n      var e = \"function\" == typeof t && t.constructor;\n      return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n    }, e.mark = function (t) {\n      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n    }, e.awrap = function (t) {\n      return {\n        __await: t\n      };\n    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n      return this;\n    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n      void 0 === i && (i = Promise);\n      var a = new AsyncIterator(wrap(t, r, n, o), i);\n      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n        return t.done ? t.value : a.next();\n      });\n    }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n      return this;\n    }), define(g, \"toString\", function () {\n      return \"[object Generator]\";\n    }), e.keys = function (t) {\n      var e = Object(t),\n        r = [];\n      for (var n in e) r.push(n);\n      return r.reverse(), function next() {\n        for (; r.length;) {\n          var t = r.pop();\n          if (t in e) return next.value = t, next.done = !1, next;\n        }\n        return next.done = !0, next;\n      };\n    }, e.values = values, Context.prototype = {\n      constructor: Context,\n      reset: function (e) {\n        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n      },\n      stop: function () {\n        this.done = !0;\n        var t = this.tryEntries[0].completion;\n        if (\"throw\" === t.type) throw t.arg;\n        return this.rval;\n      },\n      dispatchException: function (e) {\n        if (this.done) throw e;\n        var r = this;\n        function handle(n, o) {\n          return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n        }\n        for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n          var i = this.tryEntries[o],\n            a = i.completion;\n          if (\"root\" === i.tryLoc) return handle(\"end\");\n          if (i.tryLoc <= this.prev) {\n            var c = n.call(i, \"catchLoc\"),\n              u = n.call(i, \"finallyLoc\");\n            if (c && u) {\n              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n            } else if (c) {\n              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n            } else {\n              if (!u) throw Error(\"try statement without catch or finally\");\n              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n            }\n          }\n        }\n      },\n      abrupt: function (t, e) {\n        for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n          var o = this.tryEntries[r];\n          if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n            var i = o;\n            break;\n          }\n        }\n        i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n        var a = i ? i.completion : {};\n        return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n      },\n      complete: function (t, e) {\n        if (\"throw\" === t.type) throw t.arg;\n        return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n      },\n      finish: function (t) {\n        for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n          var r = this.tryEntries[e];\n          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n        }\n      },\n      catch: function (t) {\n        for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n          var r = this.tryEntries[e];\n          if (r.tryLoc === t) {\n            var n = r.completion;\n            if (\"throw\" === n.type) {\n              var o = n.arg;\n              resetTryEntry(r);\n            }\n            return o;\n          }\n        }\n        throw Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (e, r, n) {\n        return this.delegate = {\n          iterator: values(e),\n          resultName: r,\n          nextLoc: n\n        }, \"next\" === this.method && (this.arg = t), y;\n      }\n    }, e;\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r || \"default\");\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n\n  var Versions = {\n    CLASSIC: 'classic',\n    V1: 'v1'\n  };\n  var DefaultVersion = Versions.V1;\n  var PaddleClassicCDNUrl = 'https://cdn.paddle.com/paddle/paddle.js';\n  var PaddleBillingCDNUrl = 'https://cdn.paddle.com/paddle/v2/paddle.js';\n  var PaddleClassicInfo = {\n    url: PaddleClassicCDNUrl\n  };\n  var PaddleBillingV1Info = {\n    url: PaddleBillingCDNUrl\n  };\n\n  function findScript(cdnUrl) {\n    return document.querySelector(\"script[src=\\\"\".concat(cdnUrl, \"\\\"]\")) || undefined;\n  }\n  function injectScript(src) {\n    var script = document.createElement('script');\n    script.src = src;\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n      throw new Error('Cannot inject Paddle.js. It needs a <head> or <body> element.');\n    }\n    headOrBody.appendChild(script);\n    return script;\n  }\n  var promiseMap = {\n    classic: undefined,\n    v1: undefined\n  };\n  var VersionToPaddleMap = {\n    classic: 'PaddleClassic',\n    v1: 'PaddleBillingV1'\n  };\n  function loadFromCDN(version) {\n    var _getCDNInfoBasedOnVer;\n    var cdnUrl = (_getCDNInfoBasedOnVer = getCDNInfoBasedOnVersion(version)) === null || _getCDNInfoBasedOnVer === void 0 ? void 0 : _getCDNInfoBasedOnVer.url;\n    if (!cdnUrl) {\n      return;\n    }\n    // Return promise on re-renders\n    var existingPromise = promiseMap[version];\n    var paddleInstanceName = VersionToPaddleMap[version];\n    if (existingPromise !== undefined) {\n      return existingPromise;\n    }\n    promiseMap[version] = new Promise(function (resolve, reject) {\n      if (typeof window === 'undefined') {\n        // Return undefined in a server side environment\n        resolve(undefined);\n        return;\n      }\n      // Return Paddle instance if it is already initialized\n      if (window[paddleInstanceName] || window.Paddle) {\n        resolve(window[paddleInstanceName] || window.Paddle);\n        return;\n      }\n      try {\n        // Inject if paddle.js script tag is not found\n        var script = findScript(cdnUrl);\n        if (!script) {\n          script = injectScript(cdnUrl);\n        }\n        // Wait for `load` event before returning\n        script.addEventListener('load', function () {\n          if (window[paddleInstanceName] || window.Paddle) {\n            resolve(window[paddleInstanceName] || window.Paddle);\n          } else {\n            reject(new Error('Paddle.js not available'));\n          }\n        });\n        // Show an error if loading fails\n        script.addEventListener('error', function () {\n          reject(new Error(\"Failed to load Paddle.js - \".concat(version)));\n        });\n      } catch (error) {\n        reject(error);\n        return;\n      }\n    });\n    return promiseMap[version];\n  }\n  function getCDNInfoBasedOnVersion(version) {\n    if (version === Versions.CLASSIC) {\n      return PaddleClassicInfo;\n    }\n    if (version === Versions.V1) {\n      return PaddleBillingV1Info;\n    } else {\n      console.error('[Paddle] Unknown Paddle Version');\n      return;\n    }\n  }\n\n  var _excluded = [\"environment\", \"version\"],\n    _excluded2 = [\"environment\", \"version\"];\n  function initializePaddleBillingV1(options, paddle) {\n    var environment = options.environment;\n      options.version;\n      var rest = _objectWithoutProperties(options, _excluded);\n    try {\n      if (environment) {\n        paddle.Environment.set(environment);\n      }\n      if (paddle.Initialized) {\n        paddle.Update(_objectSpread2({}, rest));\n      } else {\n        paddle.Initialize(_objectSpread2({}, rest));\n      }\n    } catch (e) {\n      console.warn('[Paddle] Paddle Initialization failed. Please check the inputs', e);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function initializePaddleClassic(options, paddle) {\n    var environment = options.environment;\n      options.version;\n      var rest = _objectWithoutProperties(options, _excluded2);\n    try {\n      if (environment) {\n        paddle.Environment.set(environment);\n      }\n      paddle.Setup(_objectSpread2({}, rest));\n    } catch (e) {\n      console.warn('[Paddle] Paddle Initialization failed. Please check the inputs', e);\n    }\n  }\n\n  // Note: The enums in this file is only for `src`. Typescript will also need it added to the `types` directory for usage.\n  exports.CheckoutEventNames = void 0;\n  (function (CheckoutEventNames) {\n    CheckoutEventNames[\"CHECKOUT_LOADED\"] = \"checkout.loaded\";\n    CheckoutEventNames[\"CHECKOUT_CLOSED\"] = \"checkout.closed\";\n    CheckoutEventNames[\"CHECKOUT_UPDATED\"] = \"checkout.updated\";\n    CheckoutEventNames[\"CHECKOUT_COMPLETED\"] = \"checkout.completed\";\n    CheckoutEventNames[\"CHECKOUT_ERROR\"] = \"checkout.error\";\n    CheckoutEventNames[\"CHECKOUT_FAILED\"] = \"checkout.failed\";\n    CheckoutEventNames[\"CHECKOUT_ITEMS_UPDATED\"] = \"checkout.items.updated\";\n    CheckoutEventNames[\"CHECKOUT_ITEMS_REMOVED\"] = \"checkout.items.removed\";\n    CheckoutEventNames[\"CHECKOUT_CUSTOMER_CREATED\"] = \"checkout.customer.created\";\n    CheckoutEventNames[\"CHECKOUT_CUSTOMER_UPDATED\"] = \"checkout.customer.updated\";\n    CheckoutEventNames[\"CHECKOUT_CUSTOMER_REMOVED\"] = \"checkout.customer.removed\";\n    CheckoutEventNames[\"CHECKOUT_PAYMENT_SELECTED\"] = \"checkout.payment.selected\";\n    CheckoutEventNames[\"CHECKOUT_PAYMENT_INITIATED\"] = \"checkout.payment.initiated\";\n    CheckoutEventNames[\"CHECKOUT_PAYMENT_FAILED\"] = \"checkout.payment.failed\";\n    CheckoutEventNames[\"CHECKOUT_DISCOUNT_APPLIED\"] = \"checkout.discount.applied\";\n    CheckoutEventNames[\"CHECKOUT_DISCOUNT_REMOVED\"] = \"checkout.discount.removed\";\n  })(exports.CheckoutEventNames || (exports.CheckoutEventNames = {}));\n  exports.CheckoutEventsTimePeriodInterval = void 0;\n  (function (CheckoutEventsTimePeriodInterval) {\n    CheckoutEventsTimePeriodInterval[\"DAY\"] = \"day\";\n    CheckoutEventsTimePeriodInterval[\"WEEK\"] = \"week\";\n    CheckoutEventsTimePeriodInterval[\"MONTH\"] = \"month\";\n    CheckoutEventsTimePeriodInterval[\"YEAR\"] = \"year\";\n  })(exports.CheckoutEventsTimePeriodInterval || (exports.CheckoutEventsTimePeriodInterval = {}));\n  exports.CheckoutEventsPaymentMethodTypes = void 0;\n  (function (CheckoutEventsPaymentMethodTypes) {\n    CheckoutEventsPaymentMethodTypes[\"ALIPAY\"] = \"alipay\";\n    CheckoutEventsPaymentMethodTypes[\"APPLE_PAY\"] = \"apple-pay\";\n    CheckoutEventsPaymentMethodTypes[\"CARD\"] = \"card\";\n    CheckoutEventsPaymentMethodTypes[\"GOOGLE_PAY\"] = \"google-pay\";\n    CheckoutEventsPaymentMethodTypes[\"IDEAL\"] = \"ideal\";\n    CheckoutEventsPaymentMethodTypes[\"PAYPAL\"] = \"paypal\";\n    CheckoutEventsPaymentMethodTypes[\"WIRE_TRANSFER\"] = \"wire-transfer\";\n    CheckoutEventsPaymentMethodTypes[\"NONE\"] = \"none\";\n  })(exports.CheckoutEventsPaymentMethodTypes || (exports.CheckoutEventsPaymentMethodTypes = {}));\n  exports.CheckoutEventsPaymentMethodCardTypes = void 0;\n  (function (CheckoutEventsPaymentMethodCardTypes) {\n    CheckoutEventsPaymentMethodCardTypes[\"AMERICAN_EXPRESS\"] = \"american_express\";\n    CheckoutEventsPaymentMethodCardTypes[\"DINERS_CLUB\"] = \"diners_club\";\n    CheckoutEventsPaymentMethodCardTypes[\"DISCOVER\"] = \"discover\";\n    CheckoutEventsPaymentMethodCardTypes[\"JCB\"] = \"jcb\";\n    CheckoutEventsPaymentMethodCardTypes[\"MADA\"] = \"mada\";\n    CheckoutEventsPaymentMethodCardTypes[\"MAESTRO\"] = \"maestro\";\n    CheckoutEventsPaymentMethodCardTypes[\"MASTER_CARD\"] = \"mastercard\";\n    CheckoutEventsPaymentMethodCardTypes[\"UNION_PAY\"] = \"union_pay\";\n    CheckoutEventsPaymentMethodCardTypes[\"VISA\"] = \"visa\";\n    CheckoutEventsPaymentMethodCardTypes[\"UNKNOWN\"] = \"unknown\";\n  })(exports.CheckoutEventsPaymentMethodCardTypes || (exports.CheckoutEventsPaymentMethodCardTypes = {}));\n  exports.CheckoutEventsStatus = void 0;\n  (function (CheckoutEventsStatus) {\n    CheckoutEventsStatus[\"DRAFT\"] = \"draft\";\n    CheckoutEventsStatus[\"READY\"] = \"ready\";\n    CheckoutEventsStatus[\"COMPLETED\"] = \"completed\";\n    CheckoutEventsStatus[\"BILLED\"] = \"billed\";\n    CheckoutEventsStatus[\"canceled\"] = \"canceled\";\n    CheckoutEventsStatus[\"PAST_DUE\"] = \"past_due\";\n  })(exports.CheckoutEventsStatus || (exports.CheckoutEventsStatus = {}));\n\n  function initializePaddle(_x) {\n    return _initializePaddle.apply(this, arguments);\n  }\n  function _initializePaddle() {\n    _initializePaddle = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n      var requestedVersion, paddle;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            requestedVersion = (options === null || options === void 0 ? void 0 : options.version) || DefaultVersion;\n            _context.next = 3;\n            return loadFromCDN(requestedVersion);\n          case 3:\n            paddle = _context.sent;\n            if (!paddle) {\n              _context.next = 9;\n              break;\n            }\n            if (options) {\n              if (requestedVersion === Versions.V1) {\n                initializePaddleBillingV1(options, paddle);\n              } else if (requestedVersion === Versions.CLASSIC) {\n                initializePaddleClassic(options, paddle);\n              }\n            }\n            return _context.abrupt(\"return\", paddle);\n          case 9:\n            console.error('[Paddle] Error Loading Paddle');\n            return _context.abrupt(\"return\");\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return _initializePaddle.apply(this, arguments);\n  }\n  function getPaddleInstance() {\n    var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultVersion;\n    if (version === Versions.V1) {\n      return window.PaddleBillingV1 || window.Paddle;\n    } else if (version === Versions.CLASSIC) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return window.PaddleClassic || window.Paddle;\n    } else {\n      console.error('[Paddle] Unknown Paddle Version');\n      return;\n    }\n  }\n\n  exports.getPaddleInstance = getPaddleInstance;\n  exports.initializePaddle = initializePaddle;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhZGRsZS9wYWRkbGUtanMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUN1RztBQUN6RyxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFFBQVE7QUFDUiwyQ0FBMkM7QUFDM0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdFQUFnRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRGQUE0RjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEZBQTRGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0dBQW9HO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9FQUFvRTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbHBkZWNrLy4vbm9kZV9tb2R1bGVzL0BwYWRkbGUvcGFkZGxlLWpzL2Rpc3QvaW5kZXguanM/NzZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnBhZGRsZSA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChuLCB0LCBlLCByLCBvLCBhLCBjKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpID0gblthXShjKSxcbiAgICAgICAgdSA9IGkudmFsdWU7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgcmV0dXJuIHZvaWQgZShuKTtcbiAgICB9XG4gICAgaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pO1xuICB9XG4gIGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICBlID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7XG4gICAgICAgIHZhciBhID0gbi5hcHBseSh0LCBlKTtcbiAgICAgICAgZnVuY3Rpb24gX25leHQobikge1xuICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3Rocm93KG4pIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBuKTtcbiAgICAgICAgfVxuICAgICAgICBfbmV4dCh2b2lkIDApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICAgIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSkgOiBlW3JdID0gdCwgZTtcbiAgfVxuICBmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gICAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHtcbiAgICBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307XG4gICAgdmFyIG8sXG4gICAgICByLFxuICAgICAgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgICBmb3IgKHIgPSAwOyByIDwgcy5sZW5ndGg7IHIrKykgbyA9IHNbcl0sIHQuaW5jbHVkZXMobykgfHwge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7XG4gICAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkge1xuICAgICAgaWYgKGUuaW5jbHVkZXMobikpIGNvbnRpbnVlO1xuICAgICAgdFtuXSA9IHJbbl07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gICAgX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgdmFyIHQsXG4gICAgICBlID0ge30sXG4gICAgICByID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIG4gPSByLmhhc093blByb3BlcnR5LFxuICAgICAgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB0W2VdID0gci52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBpID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgIGEgPSBpLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLFxuICAgICAgYyA9IGkuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgICAgdSA9IGkudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gICAgZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgZSwge1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgfSksIHRbZV07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkZWZpbmUoe30sIFwiXCIpO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIGRlZmluZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiB0W2VdID0gcjtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBlICYmIGUucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gZSA6IEdlbmVyYXRvcixcbiAgICAgICAgYSA9IE9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLFxuICAgICAgICBjID0gbmV3IENvbnRleHQobiB8fCBbXSk7XG4gICAgICByZXR1cm4gbyhhLCBcIl9pbnZva2VcIiwge1xuICAgICAgICB2YWx1ZTogbWFrZUludm9rZU1ldGhvZCh0LCByLCBjKVxuICAgICAgfSksIGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyeUNhdGNoKHQsIGUsIHIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICBhcmc6IHQuY2FsbChlLCByKVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgICBhcmc6IHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZS53cmFwID0gd3JhcDtcbiAgICB2YXIgaCA9IFwic3VzcGVuZGVkU3RhcnRcIixcbiAgICAgIGwgPSBcInN1c3BlbmRlZFlpZWxkXCIsXG4gICAgICBmID0gXCJleGVjdXRpbmdcIixcbiAgICAgIHMgPSBcImNvbXBsZXRlZFwiLFxuICAgICAgeSA9IHt9O1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cbiAgICB2YXIgcCA9IHt9O1xuICAgIGRlZmluZShwLCBhLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB2YXIgZCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIHYgPSBkICYmIGQoZCh2YWx1ZXMoW10pKSk7XG4gICAgdiAmJiB2ICE9PSByICYmIG4uY2FsbCh2LCBhKSAmJiAocCA9IHYpO1xuICAgIHZhciBnID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocCk7XG4gICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHQpIHtcbiAgICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRlZmluZSh0LCBlLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IodCwgZSkge1xuICAgICAgZnVuY3Rpb24gaW52b2tlKHIsIG8sIGksIGEpIHtcbiAgICAgICAgdmFyIGMgPSB0cnlDYXRjaCh0W3JdLCB0LCBvKTtcbiAgICAgICAgaWYgKFwidGhyb3dcIiAhPT0gYy50eXBlKSB7XG4gICAgICAgICAgdmFyIHUgPSBjLmFyZyxcbiAgICAgICAgICAgIGggPSB1LnZhbHVlO1xuICAgICAgICAgIHJldHVybiBoICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGggJiYgbi5jYWxsKGgsIFwiX19hd2FpdFwiKSA/IGUucmVzb2x2ZShoLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdCwgaSwgYSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIHQsIGksIGEpO1xuICAgICAgICAgIH0pIDogZS5yZXNvbHZlKGgpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHUudmFsdWUgPSB0LCBpKHUpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgdCwgaSwgYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYShjLmFyZyk7XG4gICAgICB9XG4gICAgICB2YXIgcjtcbiAgICAgIG8odGhpcywgXCJfaW52b2tlXCIsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgICAgaW52b2tlKHQsIG4sIGUsIHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByID0gciA/IHIudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoZSwgciwgbikge1xuICAgICAgdmFyIG8gPSBoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBhKSB7XG4gICAgICAgIGlmIChvID09PSBmKSB0aHJvdyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgIGlmIChvID09PSBzKSB7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gaSkgdGhyb3cgYTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgICAgICBkb25lOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuLm1ldGhvZCA9IGksIG4uYXJnID0gYTs7KSB7XG4gICAgICAgICAgdmFyIGMgPSBuLmRlbGVnYXRlO1xuICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICB2YXIgdSA9IG1heWJlSW52b2tlRGVsZWdhdGUoYywgbik7XG4gICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICBpZiAodSA9PT0geSkgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJuZXh0XCIgPT09IG4ubWV0aG9kKSBuLnNlbnQgPSBuLl9zZW50ID0gbi5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBuLm1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKG8gPT09IGgpIHRocm93IG8gPSBzLCBuLmFyZztcbiAgICAgICAgICAgIG4uZGlzcGF0Y2hFeGNlcHRpb24obi5hcmcpO1xuICAgICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBuLm1ldGhvZCAmJiBuLmFicnVwdChcInJldHVyblwiLCBuLmFyZyk7XG4gICAgICAgICAgbyA9IGY7XG4gICAgICAgICAgdmFyIHAgPSB0cnlDYXRjaChlLCByLCBuKTtcbiAgICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcC50eXBlKSB7XG4gICAgICAgICAgICBpZiAobyA9IG4uZG9uZSA/IHMgOiBsLCBwLmFyZyA9PT0geSkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogcC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IG4uZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJ0aHJvd1wiID09PSBwLnR5cGUgJiYgKG8gPSBzLCBuLm1ldGhvZCA9IFwidGhyb3dcIiwgbi5hcmcgPSBwLmFyZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZSwgcikge1xuICAgICAgdmFyIG4gPSByLm1ldGhvZCxcbiAgICAgICAgbyA9IGUuaXRlcmF0b3Jbbl07XG4gICAgICBpZiAobyA9PT0gdCkgcmV0dXJuIHIuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG4gJiYgZS5pdGVyYXRvci5yZXR1cm4gJiYgKHIubWV0aG9kID0gXCJyZXR1cm5cIiwgci5hcmcgPSB0LCBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpLCBcInRocm93XCIgPT09IHIubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBuICYmIChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBuICsgXCInIG1ldGhvZFwiKSksIHk7XG4gICAgICB2YXIgaSA9IHRyeUNhdGNoKG8sIGUuaXRlcmF0b3IsIHIuYXJnKTtcbiAgICAgIGlmIChcInRocm93XCIgPT09IGkudHlwZSkgcmV0dXJuIHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IGkuYXJnLCByLmRlbGVnYXRlID0gbnVsbCwgeTtcbiAgICAgIHZhciBhID0gaS5hcmc7XG4gICAgICByZXR1cm4gYSA/IGEuZG9uZSA/IChyW2UucmVzdWx0TmFtZV0gPSBhLnZhbHVlLCByLm5leHQgPSBlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IHIubWV0aG9kICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCByLmRlbGVnYXRlID0gbnVsbCwgeSkgOiBhIDogKHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgci5kZWxlZ2F0ZSA9IG51bGwsIHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkodCkge1xuICAgICAgdmFyIGUgPSB7XG4gICAgICAgIHRyeUxvYzogdFswXVxuICAgICAgfTtcbiAgICAgIDEgaW4gdCAmJiAoZS5jYXRjaExvYyA9IHRbMV0pLCAyIGluIHQgJiYgKGUuZmluYWxseUxvYyA9IHRbMl0sIGUuYWZ0ZXJMb2MgPSB0WzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkodCkge1xuICAgICAgdmFyIGUgPSB0LmNvbXBsZXRpb24gfHwge307XG4gICAgICBlLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgZS5hcmcsIHQuY29tcGxldGlvbiA9IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbnRleHQodCkge1xuICAgICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgICAgfV0sIHQuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsdWVzKGUpIHtcbiAgICAgIGlmIChlIHx8IFwiXCIgPT09IGUpIHtcbiAgICAgICAgdmFyIHIgPSBlW2FdO1xuICAgICAgICBpZiAocikgcmV0dXJuIHIuY2FsbChlKTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTtcbiAgICAgICAgaWYgKCFpc05hTihlLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgbyA9IC0xLFxuICAgICAgICAgICAgaSA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgIGZvciAoOyArK28gPCBlLmxlbmd0aDspIGlmIChuLmNhbGwoZSwgbykpIHJldHVybiBuZXh0LnZhbHVlID0gZVtvXSwgbmV4dC5kb25lID0gITEsIG5leHQ7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpLm5leHQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHR5cGVvZiBlICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8oZywgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgICB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIG8oR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgICAgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ICYmIHQuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gISFlICYmIChlID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSkpO1xuICAgIH0sIGUubWFyayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHQsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6ICh0Ll9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUodCwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShnKSwgdDtcbiAgICB9LCBlLmF3cmFwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9fYXdhaXQ6IHRcbiAgICAgIH07XG4gICAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBjLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZS5hc3luYyA9IGZ1bmN0aW9uICh0LCByLCBuLCBvLCBpKSB7XG4gICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSBQcm9taXNlKTtcbiAgICAgIHZhciBhID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcCh0LCByLCBuLCBvKSwgaSk7XG4gICAgICByZXR1cm4gZS5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpID8gYSA6IGEubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZG9uZSA/IHQudmFsdWUgOiBhLm5leHQoKTtcbiAgICAgIH0pO1xuICAgIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhnKSwgZGVmaW5lKGcsIHUsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoZywgYSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGRlZmluZShnLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH0pLCBlLmtleXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBPYmplY3QodCksXG4gICAgICAgIHIgPSBbXTtcbiAgICAgIGZvciAodmFyIG4gaW4gZSkgci5wdXNoKG4pO1xuICAgICAgcmV0dXJuIHIucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBmb3IgKDsgci5sZW5ndGg7KSB7XG4gICAgICAgICAgdmFyIHQgPSByLnBvcCgpO1xuICAgICAgICAgIGlmICh0IGluIGUpIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITEsIG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgICAgfTtcbiAgICB9LCBlLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB0LCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIWUpIGZvciAodmFyIHIgaW4gdGhpcykgXCJ0XCIgPT09IHIuY2hhckF0KDApICYmIG4uY2FsbCh0aGlzLCByKSAmJiAhaXNOYU4oK3Iuc2xpY2UoMSkpICYmICh0aGlzW3JdID0gdCk7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gdC50eXBlKSB0aHJvdyB0LmFyZztcbiAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGUobiwgbykge1xuICAgICAgICAgIHJldHVybiBhLnR5cGUgPSBcInRocm93XCIsIGEuYXJnID0gZSwgci5uZXh0ID0gbiwgbyAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgISFvO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIG8gPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgbyA+PSAwOyAtLW8pIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMudHJ5RW50cmllc1tvXSxcbiAgICAgICAgICAgIGEgPSBpLmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKFwicm9vdFwiID09PSBpLnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgICBpZiAoaS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgICB2YXIgYyA9IG4uY2FsbChpLCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgICB1ID0gbi5jYWxsKGksIFwiZmluYWxseUxvY1wiKTtcbiAgICAgICAgICAgIGlmIChjICYmIHUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF1KSB0aHJvdyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWJydXB0OiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLnRyeUVudHJpZXNbcl07XG4gICAgICAgICAgaWYgKG8udHJ5TG9jIDw9IHRoaXMucHJldiAmJiBuLmNhbGwobywgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IG8uZmluYWxseUxvYykge1xuICAgICAgICAgICAgdmFyIGkgPSBvO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgJiYgKFwiYnJlYWtcIiA9PT0gdCB8fCBcImNvbnRpbnVlXCIgPT09IHQpICYmIGkudHJ5TG9jIDw9IGUgJiYgZSA8PSBpLmZpbmFsbHlMb2MgJiYgKGkgPSBudWxsKTtcbiAgICAgICAgdmFyIGEgPSBpID8gaS5jb21wbGV0aW9uIDoge307XG4gICAgICAgIHJldHVybiBhLnR5cGUgPSB0LCBhLmFyZyA9IGUsIGkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gaS5maW5hbGx5TG9jLCB5KSA6IHRoaXMuY29tcGxldGUoYSk7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCIgPT09IHQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHQudHlwZSA/IHRoaXMubmV4dCA9IHQuYXJnIDogXCJyZXR1cm5cIiA9PT0gdC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gdC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSB0LnR5cGUgJiYgZSAmJiAodGhpcy5uZXh0ID0gZSksIHk7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgICAgaWYgKHIuZmluYWxseUxvYyA9PT0gdCkgcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLCByLmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShyKSwgeTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhdGNoOiBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgICAgaWYgKHIudHJ5TG9jID09PSB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHIuY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG4udHlwZSkge1xuICAgICAgICAgICAgICB2YXIgbyA9IG4uYXJnO1xuICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgfSxcbiAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIChlLCByLCBuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoZSksXG4gICAgICAgICAgcmVzdWx0TmFtZTogcixcbiAgICAgICAgICBuZXh0TG9jOiBuXG4gICAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB0KSwgeTtcbiAgICAgIH1cbiAgICB9LCBlO1xuICB9XG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbiAgfVxuXG4gIHZhciBWZXJzaW9ucyA9IHtcbiAgICBDTEFTU0lDOiAnY2xhc3NpYycsXG4gICAgVjE6ICd2MSdcbiAgfTtcbiAgdmFyIERlZmF1bHRWZXJzaW9uID0gVmVyc2lvbnMuVjE7XG4gIHZhciBQYWRkbGVDbGFzc2ljQ0ROVXJsID0gJ2h0dHBzOi8vY2RuLnBhZGRsZS5jb20vcGFkZGxlL3BhZGRsZS5qcyc7XG4gIHZhciBQYWRkbGVCaWxsaW5nQ0ROVXJsID0gJ2h0dHBzOi8vY2RuLnBhZGRsZS5jb20vcGFkZGxlL3YyL3BhZGRsZS5qcyc7XG4gIHZhciBQYWRkbGVDbGFzc2ljSW5mbyA9IHtcbiAgICB1cmw6IFBhZGRsZUNsYXNzaWNDRE5VcmxcbiAgfTtcbiAgdmFyIFBhZGRsZUJpbGxpbmdWMUluZm8gPSB7XG4gICAgdXJsOiBQYWRkbGVCaWxsaW5nQ0ROVXJsXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZFNjcmlwdChjZG5VcmwpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInNjcmlwdFtzcmM9XFxcIlwiLmNvbmNhdChjZG5VcmwsIFwiXFxcIl1cIikpIHx8IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBpbmplY3RTY3JpcHQoc3JjKSB7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgdmFyIGhlYWRPckJvZHkgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgaWYgKCFoZWFkT3JCb2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbmplY3QgUGFkZGxlLmpzLiBJdCBuZWVkcyBhIDxoZWFkPiBvciA8Ym9keT4gZWxlbWVudC4nKTtcbiAgICB9XG4gICAgaGVhZE9yQm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIHJldHVybiBzY3JpcHQ7XG4gIH1cbiAgdmFyIHByb21pc2VNYXAgPSB7XG4gICAgY2xhc3NpYzogdW5kZWZpbmVkLFxuICAgIHYxOiB1bmRlZmluZWRcbiAgfTtcbiAgdmFyIFZlcnNpb25Ub1BhZGRsZU1hcCA9IHtcbiAgICBjbGFzc2ljOiAnUGFkZGxlQ2xhc3NpYycsXG4gICAgdjE6ICdQYWRkbGVCaWxsaW5nVjEnXG4gIH07XG4gIGZ1bmN0aW9uIGxvYWRGcm9tQ0ROKHZlcnNpb24pIHtcbiAgICB2YXIgX2dldENETkluZm9CYXNlZE9uVmVyO1xuICAgIHZhciBjZG5VcmwgPSAoX2dldENETkluZm9CYXNlZE9uVmVyID0gZ2V0Q0ROSW5mb0Jhc2VkT25WZXJzaW9uKHZlcnNpb24pKSA9PT0gbnVsbCB8fCBfZ2V0Q0ROSW5mb0Jhc2VkT25WZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRDRE5JbmZvQmFzZWRPblZlci51cmw7XG4gICAgaWYgKCFjZG5VcmwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHByb21pc2Ugb24gcmUtcmVuZGVyc1xuICAgIHZhciBleGlzdGluZ1Byb21pc2UgPSBwcm9taXNlTWFwW3ZlcnNpb25dO1xuICAgIHZhciBwYWRkbGVJbnN0YW5jZU5hbWUgPSBWZXJzaW9uVG9QYWRkbGVNYXBbdmVyc2lvbl07XG4gICAgaWYgKGV4aXN0aW5nUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdQcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlTWFwW3ZlcnNpb25dID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgaW4gYSBzZXJ2ZXIgc2lkZSBlbnZpcm9ubWVudFxuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiBQYWRkbGUgaW5zdGFuY2UgaWYgaXQgaXMgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAgaWYgKHdpbmRvd1twYWRkbGVJbnN0YW5jZU5hbWVdIHx8IHdpbmRvdy5QYWRkbGUpIHtcbiAgICAgICAgcmVzb2x2ZSh3aW5kb3dbcGFkZGxlSW5zdGFuY2VOYW1lXSB8fCB3aW5kb3cuUGFkZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW5qZWN0IGlmIHBhZGRsZS5qcyBzY3JpcHQgdGFnIGlzIG5vdCBmb3VuZFxuICAgICAgICB2YXIgc2NyaXB0ID0gZmluZFNjcmlwdChjZG5VcmwpO1xuICAgICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChjZG5VcmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIGBsb2FkYCBldmVudCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh3aW5kb3dbcGFkZGxlSW5zdGFuY2VOYW1lXSB8fCB3aW5kb3cuUGFkZGxlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHdpbmRvd1twYWRkbGVJbnN0YW5jZU5hbWVdIHx8IHdpbmRvdy5QYWRkbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQYWRkbGUuanMgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTaG93IGFuIGVycm9yIGlmIGxvYWRpbmcgZmFpbHNcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBQYWRkbGUuanMgLSBcIi5jb25jYXQodmVyc2lvbikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2VNYXBbdmVyc2lvbl07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q0ROSW5mb0Jhc2VkT25WZXJzaW9uKHZlcnNpb24pIHtcbiAgICBpZiAodmVyc2lvbiA9PT0gVmVyc2lvbnMuQ0xBU1NJQykge1xuICAgICAgcmV0dXJuIFBhZGRsZUNsYXNzaWNJbmZvO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gVmVyc2lvbnMuVjEpIHtcbiAgICAgIHJldHVybiBQYWRkbGVCaWxsaW5nVjFJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbUGFkZGxlXSBVbmtub3duIFBhZGRsZSBWZXJzaW9uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdmFyIF9leGNsdWRlZCA9IFtcImVudmlyb25tZW50XCIsIFwidmVyc2lvblwiXSxcbiAgICBfZXhjbHVkZWQyID0gW1wiZW52aXJvbm1lbnRcIiwgXCJ2ZXJzaW9uXCJdO1xuICBmdW5jdGlvbiBpbml0aWFsaXplUGFkZGxlQmlsbGluZ1YxKG9wdGlvbnMsIHBhZGRsZSkge1xuICAgIHZhciBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQ7XG4gICAgICBvcHRpb25zLnZlcnNpb247XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBfZXhjbHVkZWQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcGFkZGxlLkVudmlyb25tZW50LnNldChlbnZpcm9ubWVudCk7XG4gICAgICB9XG4gICAgICBpZiAocGFkZGxlLkluaXRpYWxpemVkKSB7XG4gICAgICAgIHBhZGRsZS5VcGRhdGUoX29iamVjdFNwcmVhZDIoe30sIHJlc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZGRsZS5Jbml0aWFsaXplKF9vYmplY3RTcHJlYWQyKHt9LCByZXN0KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKCdbUGFkZGxlXSBQYWRkbGUgSW5pdGlhbGl6YXRpb24gZmFpbGVkLiBQbGVhc2UgY2hlY2sgdGhlIGlucHV0cycsIGUpO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBmdW5jdGlvbiBpbml0aWFsaXplUGFkZGxlQ2xhc3NpYyhvcHRpb25zLCBwYWRkbGUpIHtcbiAgICB2YXIgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50O1xuICAgICAgb3B0aW9ucy52ZXJzaW9uO1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgX2V4Y2x1ZGVkMik7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbnZpcm9ubWVudCkge1xuICAgICAgICBwYWRkbGUuRW52aXJvbm1lbnQuc2V0KGVudmlyb25tZW50KTtcbiAgICAgIH1cbiAgICAgIHBhZGRsZS5TZXR1cChfb2JqZWN0U3ByZWFkMih7fSwgcmVzdCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignW1BhZGRsZV0gUGFkZGxlIEluaXRpYWxpemF0aW9uIGZhaWxlZC4gUGxlYXNlIGNoZWNrIHRoZSBpbnB1dHMnLCBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBOb3RlOiBUaGUgZW51bXMgaW4gdGhpcyBmaWxlIGlzIG9ubHkgZm9yIGBzcmNgLiBUeXBlc2NyaXB0IHdpbGwgYWxzbyBuZWVkIGl0IGFkZGVkIHRvIHRoZSBgdHlwZXNgIGRpcmVjdG9yeSBmb3IgdXNhZ2UuXG4gIGV4cG9ydHMuQ2hlY2tvdXRFdmVudE5hbWVzID0gdm9pZCAwO1xuICAoZnVuY3Rpb24gKENoZWNrb3V0RXZlbnROYW1lcykge1xuICAgIENoZWNrb3V0RXZlbnROYW1lc1tcIkNIRUNLT1VUX0xPQURFRFwiXSA9IFwiY2hlY2tvdXQubG9hZGVkXCI7XG4gICAgQ2hlY2tvdXRFdmVudE5hbWVzW1wiQ0hFQ0tPVVRfQ0xPU0VEXCJdID0gXCJjaGVja291dC5jbG9zZWRcIjtcbiAgICBDaGVja291dEV2ZW50TmFtZXNbXCJDSEVDS09VVF9VUERBVEVEXCJdID0gXCJjaGVja291dC51cGRhdGVkXCI7XG4gICAgQ2hlY2tvdXRFdmVudE5hbWVzW1wiQ0hFQ0tPVVRfQ09NUExFVEVEXCJdID0gXCJjaGVja291dC5jb21wbGV0ZWRcIjtcbiAgICBDaGVja291dEV2ZW50TmFtZXNbXCJDSEVDS09VVF9FUlJPUlwiXSA9IFwiY2hlY2tvdXQuZXJyb3JcIjtcbiAgICBDaGVja291dEV2ZW50TmFtZXNbXCJDSEVDS09VVF9GQUlMRURcIl0gPSBcImNoZWNrb3V0LmZhaWxlZFwiO1xuICAgIENoZWNrb3V0RXZlbnROYW1lc1tcIkNIRUNLT1VUX0lURU1TX1VQREFURURcIl0gPSBcImNoZWNrb3V0Lml0ZW1zLnVwZGF0ZWRcIjtcbiAgICBDaGVja291dEV2ZW50TmFtZXNbXCJDSEVDS09VVF9JVEVNU19SRU1PVkVEXCJdID0gXCJjaGVja291dC5pdGVtcy5yZW1vdmVkXCI7XG4gICAgQ2hlY2tvdXRFdmVudE5hbWVzW1wiQ0hFQ0tPVVRfQ1VTVE9NRVJfQ1JFQVRFRFwiXSA9IFwiY2hlY2tvdXQuY3VzdG9tZXIuY3JlYXRlZFwiO1xuICAgIENoZWNrb3V0RXZlbnROYW1lc1tcIkNIRUNLT1VUX0NVU1RPTUVSX1VQREFURURcIl0gPSBcImNoZWNrb3V0LmN1c3RvbWVyLnVwZGF0ZWRcIjtcbiAgICBDaGVja291dEV2ZW50TmFtZXNbXCJDSEVDS09VVF9DVVNUT01FUl9SRU1PVkVEXCJdID0gXCJjaGVja291dC5jdXN0b21lci5yZW1vdmVkXCI7XG4gICAgQ2hlY2tvdXRFdmVudE5hbWVzW1wiQ0hFQ0tPVVRfUEFZTUVOVF9TRUxFQ1RFRFwiXSA9IFwiY2hlY2tvdXQucGF5bWVudC5zZWxlY3RlZFwiO1xuICAgIENoZWNrb3V0RXZlbnROYW1lc1tcIkNIRUNLT1VUX1BBWU1FTlRfSU5JVElBVEVEXCJdID0gXCJjaGVja291dC5wYXltZW50LmluaXRpYXRlZFwiO1xuICAgIENoZWNrb3V0RXZlbnROYW1lc1tcIkNIRUNLT1VUX1BBWU1FTlRfRkFJTEVEXCJdID0gXCJjaGVja291dC5wYXltZW50LmZhaWxlZFwiO1xuICAgIENoZWNrb3V0RXZlbnROYW1lc1tcIkNIRUNLT1VUX0RJU0NPVU5UX0FQUExJRURcIl0gPSBcImNoZWNrb3V0LmRpc2NvdW50LmFwcGxpZWRcIjtcbiAgICBDaGVja291dEV2ZW50TmFtZXNbXCJDSEVDS09VVF9ESVNDT1VOVF9SRU1PVkVEXCJdID0gXCJjaGVja291dC5kaXNjb3VudC5yZW1vdmVkXCI7XG4gIH0pKGV4cG9ydHMuQ2hlY2tvdXRFdmVudE5hbWVzIHx8IChleHBvcnRzLkNoZWNrb3V0RXZlbnROYW1lcyA9IHt9KSk7XG4gIGV4cG9ydHMuQ2hlY2tvdXRFdmVudHNUaW1lUGVyaW9kSW50ZXJ2YWwgPSB2b2lkIDA7XG4gIChmdW5jdGlvbiAoQ2hlY2tvdXRFdmVudHNUaW1lUGVyaW9kSW50ZXJ2YWwpIHtcbiAgICBDaGVja291dEV2ZW50c1RpbWVQZXJpb2RJbnRlcnZhbFtcIkRBWVwiXSA9IFwiZGF5XCI7XG4gICAgQ2hlY2tvdXRFdmVudHNUaW1lUGVyaW9kSW50ZXJ2YWxbXCJXRUVLXCJdID0gXCJ3ZWVrXCI7XG4gICAgQ2hlY2tvdXRFdmVudHNUaW1lUGVyaW9kSW50ZXJ2YWxbXCJNT05USFwiXSA9IFwibW9udGhcIjtcbiAgICBDaGVja291dEV2ZW50c1RpbWVQZXJpb2RJbnRlcnZhbFtcIllFQVJcIl0gPSBcInllYXJcIjtcbiAgfSkoZXhwb3J0cy5DaGVja291dEV2ZW50c1RpbWVQZXJpb2RJbnRlcnZhbCB8fCAoZXhwb3J0cy5DaGVja291dEV2ZW50c1RpbWVQZXJpb2RJbnRlcnZhbCA9IHt9KSk7XG4gIGV4cG9ydHMuQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kVHlwZXMgPSB2b2lkIDA7XG4gIChmdW5jdGlvbiAoQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kVHlwZXMpIHtcbiAgICBDaGVja291dEV2ZW50c1BheW1lbnRNZXRob2RUeXBlc1tcIkFMSVBBWVwiXSA9IFwiYWxpcGF5XCI7XG4gICAgQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kVHlwZXNbXCJBUFBMRV9QQVlcIl0gPSBcImFwcGxlLXBheVwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzW1wiQ0FSRFwiXSA9IFwiY2FyZFwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzW1wiR09PR0xFX1BBWVwiXSA9IFwiZ29vZ2xlLXBheVwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzW1wiSURFQUxcIl0gPSBcImlkZWFsXCI7XG4gICAgQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kVHlwZXNbXCJQQVlQQUxcIl0gPSBcInBheXBhbFwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzW1wiV0lSRV9UUkFOU0ZFUlwiXSA9IFwid2lyZS10cmFuc2ZlclwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzW1wiTk9ORVwiXSA9IFwibm9uZVwiO1xuICB9KShleHBvcnRzLkNoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzIHx8IChleHBvcnRzLkNoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZFR5cGVzID0ge30pKTtcbiAgZXhwb3J0cy5DaGVja291dEV2ZW50c1BheW1lbnRNZXRob2RDYXJkVHlwZXMgPSB2b2lkIDA7XG4gIChmdW5jdGlvbiAoQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kQ2FyZFR5cGVzKSB7XG4gICAgQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kQ2FyZFR5cGVzW1wiQU1FUklDQU5fRVhQUkVTU1wiXSA9IFwiYW1lcmljYW5fZXhwcmVzc1wiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZENhcmRUeXBlc1tcIkRJTkVSU19DTFVCXCJdID0gXCJkaW5lcnNfY2x1YlwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZENhcmRUeXBlc1tcIkRJU0NPVkVSXCJdID0gXCJkaXNjb3ZlclwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZENhcmRUeXBlc1tcIkpDQlwiXSA9IFwiamNiXCI7XG4gICAgQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kQ2FyZFR5cGVzW1wiTUFEQVwiXSA9IFwibWFkYVwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZENhcmRUeXBlc1tcIk1BRVNUUk9cIl0gPSBcIm1hZXN0cm9cIjtcbiAgICBDaGVja291dEV2ZW50c1BheW1lbnRNZXRob2RDYXJkVHlwZXNbXCJNQVNURVJfQ0FSRFwiXSA9IFwibWFzdGVyY2FyZFwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZENhcmRUeXBlc1tcIlVOSU9OX1BBWVwiXSA9IFwidW5pb25fcGF5XCI7XG4gICAgQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kQ2FyZFR5cGVzW1wiVklTQVwiXSA9IFwidmlzYVwiO1xuICAgIENoZWNrb3V0RXZlbnRzUGF5bWVudE1ldGhvZENhcmRUeXBlc1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgfSkoZXhwb3J0cy5DaGVja291dEV2ZW50c1BheW1lbnRNZXRob2RDYXJkVHlwZXMgfHwgKGV4cG9ydHMuQ2hlY2tvdXRFdmVudHNQYXltZW50TWV0aG9kQ2FyZFR5cGVzID0ge30pKTtcbiAgZXhwb3J0cy5DaGVja291dEV2ZW50c1N0YXR1cyA9IHZvaWQgMDtcbiAgKGZ1bmN0aW9uIChDaGVja291dEV2ZW50c1N0YXR1cykge1xuICAgIENoZWNrb3V0RXZlbnRzU3RhdHVzW1wiRFJBRlRcIl0gPSBcImRyYWZ0XCI7XG4gICAgQ2hlY2tvdXRFdmVudHNTdGF0dXNbXCJSRUFEWVwiXSA9IFwicmVhZHlcIjtcbiAgICBDaGVja291dEV2ZW50c1N0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IFwiY29tcGxldGVkXCI7XG4gICAgQ2hlY2tvdXRFdmVudHNTdGF0dXNbXCJCSUxMRURcIl0gPSBcImJpbGxlZFwiO1xuICAgIENoZWNrb3V0RXZlbnRzU3RhdHVzW1wiY2FuY2VsZWRcIl0gPSBcImNhbmNlbGVkXCI7XG4gICAgQ2hlY2tvdXRFdmVudHNTdGF0dXNbXCJQQVNUX0RVRVwiXSA9IFwicGFzdF9kdWVcIjtcbiAgfSkoZXhwb3J0cy5DaGVja291dEV2ZW50c1N0YXR1cyB8fCAoZXhwb3J0cy5DaGVja291dEV2ZW50c1N0YXR1cyA9IHt9KSk7XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVBhZGRsZShfeCkge1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZVBhZGRsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIF9pbml0aWFsaXplUGFkZGxlKCkge1xuICAgIF9pbml0aWFsaXplUGFkZGxlID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUob3B0aW9ucykge1xuICAgICAgdmFyIHJlcXVlc3RlZFZlcnNpb24sIHBhZGRsZTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlcXVlc3RlZFZlcnNpb24gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZlcnNpb24pIHx8IERlZmF1bHRWZXJzaW9uO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gbG9hZEZyb21DRE4ocmVxdWVzdGVkVmVyc2lvbik7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcGFkZGxlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGlmICghcGFkZGxlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRWZXJzaW9uID09PSBWZXJzaW9ucy5WMSkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVQYWRkbGVCaWxsaW5nVjEob3B0aW9ucywgcGFkZGxlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRWZXJzaW9uID09PSBWZXJzaW9ucy5DTEFTU0lDKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZVBhZGRsZUNsYXNzaWMob3B0aW9ucywgcGFkZGxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBwYWRkbGUpO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tQYWRkbGVdIEVycm9yIExvYWRpbmcgUGFkZGxlJyk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZVBhZGRsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBhZGRsZUluc3RhbmNlKCkge1xuICAgIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBEZWZhdWx0VmVyc2lvbjtcbiAgICBpZiAodmVyc2lvbiA9PT0gVmVyc2lvbnMuVjEpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuUGFkZGxlQmlsbGluZ1YxIHx8IHdpbmRvdy5QYWRkbGU7XG4gICAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSBWZXJzaW9ucy5DTEFTU0lDKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgcmV0dXJuIHdpbmRvdy5QYWRkbGVDbGFzc2ljIHx8IHdpbmRvdy5QYWRkbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tQYWRkbGVdIFVua25vd24gUGFkZGxlIFZlcnNpb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmdldFBhZGRsZUluc3RhbmNlID0gZ2V0UGFkZGxlSW5zdGFuY2U7XG4gIGV4cG9ydHMuaW5pdGlhbGl6ZVBhZGRsZSA9IGluaXRpYWxpemVQYWRkbGU7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paddle/paddle-js/dist/index.js\n");

/***/ })

};
;